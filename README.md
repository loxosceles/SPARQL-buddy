# SPARQL-Buddy
## Command line tool for querying SPARQL endpoints
SPARQL-buddy is a customizable and extensible collection of python methods which take
away the hassle of c&p queries into different web interfaces or GUIs for testing and
tweaking your SPARQL queries on varying datasets. 

This script also takes care of the complete setup and offers easy ways to change the
configuration, save queries to text files without having to select a folder, change
datasets on the fly and work with any number of them concurrently, compare responses,
reuse them in different contexts, and so forth...

This is probably for you only if you feel more at home at your personalized CLI
environment than in any web or GUI interface which all come with their very own
advantages and limitations. 

### Setup
Make sure the script is on your PYTHONPATH. From iPython:

    import sparql_buddy as sb

Now your good to go. For convenience the script creates a first SPARQL query object.
This object uses http://dbpedia.org as default endpoint. To make it easier to access
I usually rename it:

    sq = sb.sq


### Usage
#### Accessing default configuration
This version of SPARQL-Buddy is meant to be imported into iPython, at least this is
how I like to use it. Nothing will stop you from building your own GUI or web
interface if you feel more comfortable with that.
This quick introduction assumes that you will be following the examples using
iPython.

Check the default URL and set a different one:

    sq.url    # 'http://dbpedia.org/sparql'
    sq.url = 'http://semantic.ckan.net/sparql/'
    sq.url    # 'http://semantic.ckan.net/sparql/'
You can change every default setting in the same way.  

Check the default query file folder:

    sq.query_file_folder  # './queries'

The abbreviated prefixes which map to namespaces in your queries are saved in the
prefix file. You don't have to include the PREFIX section into your queries, only the
abbreviated prefixes in the **first** line of your query. Look at the query section
for an example (inline query).\
The default prefix configuration file:
  
    sq.prefix_file  # './prefixes.csv'

To see your prefix-namespace mappings (loaded into memory at startup):
  
    sq.prefix_mapping_dict

    # {'owl': '<http://www.w3.org/2002/07/owl#>',
    #  'dbo': '<http://dbpedia.org/ontology/>',
    #  'dbp': '<http://dbpedia.org/property>',
    #  'dbr': '<http://dbpedia.org/resource/>',
    #  'dc': '<http://purl.org/dc/elemental/1.1/>',
    #  ...


List your saved queries (inside the query file folder):

    sq.query_files()

    # {0: 'movies',
    #  1: 'russian_cities',
    #  2: 'avail_graphs',
    #  3: 'landlocked_countries',
    #  4: 'person_1',
    #  ...

#### Running queries

There are three ways of running a query:
1. Writing your query from scratch (Inline)
2. Referencing a saved query (inside the query folder) by number
3. Referencing a saved query by name

##### 1. Inline query:
  
    sq.run_query("""dbr dbo foaf
      SELECT ?name ?birth ?death ?person 
        WHERE {      
            ?person dbo:birthPlace dbr:Berlin .      
            ?person dbo:birthDate ?birth .      
            ?person foaf:name ?name .      
            ?person dbo:deathDate ?death .      
            FILTER (?birth < "1900-01-01"^^xsd:date) . 
        } ORDER BY ?name
    """)

Note that the query is surrounded by triple quotes which in Python is a multiple line
string literal. Also, it is important to define prefixes. With inline queries this
has to be done on the first line using the abbreviations defined in the `prefix.csv`
file.

##### 2. By number (number generated by output of `query_files()`:

    sq.run_query(1)

##### 3. By name (name of any of the files in the `query_file_folder`)
  
    sq.run_query('landlocked_countries')

#### Working with queries
You can retrieve the latest query object which holds the following information:
- Query environment (URL, prefix file path, query file folder path, ... )
- Query
- Response

Since every query which has been run in a particular session is saved as an object
with that information attached you can now run different methods on it. It is
convenient to assign the latest query object for instance if you want to refine a
query:

    a =  sq.latest_qobj()  # same as sq.latest_qobj(1)

This method take an integer as argument, which will let you access not only the
latest but also earlier queries by index. So `2`will get the penultimate query, `3`
the antepenultimate, and so forth.

Now with that new variable you can extract the information:

    a.print_query()        # returns query, prefixes translated, pretty printed JSON
    a.print_response()     # returns response, pretty printed JSON
    a.print_raw_response() # returns response, single string, no spaces

It is also possible to access the query and response directly, skipping the pretty
printing:

    a.query      # returns query, prefixes translated
    a.rquery     # returns query, prefixes abbreviated
    a.response   # returns response

Especially the `rquery` is useful if you want to reuse your previous query and save a
modified version of it. This way you don't introduce more formatting characters into
the new versions.

In order to see only the variables of the result without any clutter you can filter
them:

    a.filter_attributes()
      
    # person: http://dbpedia.org/resource/Annot_(artist)
    # name: "Annot" (Annot Jacobi)
    # death: 1981-10-20
    # birth: 1894-12-27

    # person: http://dbpedia.org/resource/Adelbert_Theodor_Wangemann
    # name: A. Theo E. Wangemann
    # death: 1906
    # birth: 1855-02-13

    # person: http://dbpedia.org/resource/Lina_Abarbanell
    # name: Abarbanell, Lina
    # death: 1963-01-06
    # birth: 1879-01-03
    # ...

#### Keyword search

Keyword search has tree modes:
  1. Extended search
  2. Strict search
  3. Quick search

##### 1. Extended search (default)
    
    sq.keyword_search("Mahatma Gandhi")

    # {
    #   "name": {
    #       "type": "literal",
    #       "value": "Statue of Mahatma Gandhi, Gandhi Maidan",
    #       "xml:lang": "en"
    #   },
    #   "place": {
    #       "type": "uri",
    #       "value": "http://dbpedia.org/resource/Statue_of_Mahatma_Gandhi,_Gandhi_Maidan"
    #   }
    # }, {... output omitted ... },
    # {
    #   "name": {
    #       "type": "literal",
    #       "value": "Mahatma Gandhi",
    #       "xml:lang": "en"
    #   },
    #   "person": {
    #       "type": "uri",
    #       "value": "http://dbpedia.org/resource/Mahatma_Gandhi"
    #   }
    # },
    # {
    #   "name": {
    #       "type": "literal",
    #       "value": "Mahatma Gandhi Institute of Technology",
    #       "xml:lang": "en"
    #   },
    #   "organization": {
    #       "type": "uri",
    #       "value": "http://dbpedia.org/resource/Mahatma_Gandhi_Institute_of_Technology"
    # }
    # }, {... output omitted ... }], ...

As you can see from this rather long ouput example, the extended search will find any
related resource to the search string. Mahatma Gandhi was obviously a person but
other resources can be named after him for instance. The category of the "thing" (a
super category) will be show as well. Currently there are the following categories:
- Place
- Person
- Action
- Organization
- Event

Of course these categories could extended easily to embrace other types of entities.

Reusing a past query (e.g. after editing it) is as simple as that:

    sq.run_query(a.rquery)

##### 2. Strict search
The strict search will query the given search term without context. The only
modification it does does equally to the extended search is the replacing of one
blank space with an underscore.

##### 3. Quick search
Most of the times the result of the quick search is similar to the strict search. It
exists mainly because of performance since it doesn't query all the categories but
only checks if a URL for a given keyword exists. It is way faster since it fires only
one 'ask' query instead of searching the whole dataset. 

There are sometimes differences, though. For example, the keyword "Faith" doesn't
belong to any of these categories, in fact, it lacks a schema.org category altogether
(which is the vocabulary I'm using for that feature at the moment). As a consequence
it pops up with quick search but not with strict search.

#### Writing queries to file
There is a method to write a query to a file which after that you will find inside
your query folder.

    sq.query2file(sq.latest_qobj().rquery, "Gandhi_2")
    # Will write the lastest query you issued to the './query' folder under the name
    "Gandhi_2"

For quick editing you could fire `sq.query_files` to check the index and use it in
the sq.run_query(`index`) method after editing the file. 

<b>Note:</b> If you use a command line based file explorer like nerdTree for vim and
manage your windows through Tmux or some similar setup you can edit and query very
efficiently without ever leaving the terminal.

#### Listing all saved queries
Sometimes it is useful to list all your queries, also the ones which don't belong to
the current query environment. This method is not part of any specific environment
hence it is executed from the module level.

This method takes one or more query objects (or environments) and lists their query
folders so you get a quick overview of what do you have of saved queries in any of
the environments.

    sb.list_qfiles(`sq`, `obj1`, `...`)  # lists query file folder for sq and other
                                         # enviromnents.

### Collaborate
This is just a very basic tool which helped me to understand and experiment with RDF
and SPARQL in the context of Semantic Web. It is still work in progress and heavily
adapted to my personal taste and workflow.

Still, if your interested in (re-)using it, build a graphical interface around it or
want to develop any feature you're missing, feel free to do so. I'd be delighted to
get your feedback on that.

loxosceles@gmx.de
